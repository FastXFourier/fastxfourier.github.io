---
title: c2_kmutt_66_intersection
---
# ข้อสอบท้ายค่าย 2 ปีการศึกษา 2566 ศูนย์ สอวน. มหาวิทยาลัยเทคโนโลยีพระจอมเกล้าธนบุรี ข้อ [Intersection](https://grader.gchan.moe/problemset/c2_st66_intersection/)
---
### Author: Nagorn Phongphasura
---

## Problem 

### สรุปโจทย์
จะมีการลากเส้น Zigzag ขึ้น-ลง (หรืออาจไม่ต้องสลับกันก็ได้) จำนวน $N$ ครั้ง โดย Input แต่ละตัว จะบอกว่า ในการลากเส้นครั้งนั้น จะจบที่ค่า $y$ เท่าใด (Input ตัวแรก คือ $y$ เริ่มต้น) ดังภาพ

<img src="/assets/images/sweepline.png" class="floodfill">

### สิ่งที่ต้องทำ
หาจำนวนจุดตัดที่มากที่สุดที่เป็นไปได้ จากการลากเส้นขนานกับแกน $X$ จำนวน 1 เส้น

!!! note "Constraints"
    $2 \leq N \leq 10^5$<br>
    $0 \leq y_1,y_2,...,y_n \leq 10^9$

!!! note "Prerequisites"
    - `Sweep Line`

---

## Solution
### Sweep Line Algorithm
แนวคิดง่ายๆของมันนะครับ คือ:
ลองจินตนาการว่าเรามี **เส้นตรงแนวตั้ง**  
แล้วเราค่อย ๆ **เลื่อนเส้นนี้จากซ้ายไปขวา** เหมือนเครื่องสแกน  
ขณะที่เส้นเลื่อนไป เราจะ **จัดการเหตุการณ์ (event)** ทุกครั้งที่เส้นเจอสิ่งใหม่ เช่น จุดเริ่มต้นหรือจุดสิ้นสุดของช่วง  

เราจะเก็บข้อมูลว่าช่วงไหน “ยังกำลัง active” หรือช่วงไหนกำลังครอบเส้นอยู่  
เพื่อให้เรารู้ว่า ณ ตำแหน่งนั้น มีช่วงกี่ช่วงทับซ้อนกัน

1. **จัดเรียงเหตุการณ์ทั้งหมด** จากซ้ายไปขวา 
    - ตัวอย่าง: สำหรับช่วง ให้ถือว่ามี 2 เหตุการณ์ → เริ่ม (`+1`) และจบ (`-1`)
2. **เลื่อนเส้นทีละตำแหน่งเหตุการณ์**  
3. **อัพเดตสถานะ** เมื่อเจอเหตุการณ์
    - จุดเริ่ม → เพิ่มจำนวนช่วงที่ active
    - จุดจบ → ลดจำนวนช่วงที่ active
4. **ตรวจสอบค่าตอนนี้**  
    - เราสามารถเก็บค่ามากที่สุดของจำนวนช่วง active ได้ตลอดเวลา
5. เมื่อเส้นกวาดจนครบทุกเหตุการณ์ ค่ามากที่สุดคือคำตอบ

### วิธีทำ
สังเกตว่า สมมติเรามี Input
$$
y_1, y_2, y_3, \dots, y_n
$$
เราสามารถมองทุกคู่ของตัวเลขที่อยู่ติดกัน \((y_i, y_{i+1})\)  
เป็น “ช่วง” โดยในจุดเริ่มต้นของแต่ละช่วง จะมีจำนวนจุดตัดเพิ่มมา 1 และในจุดจบของแต่ละช่วง จะมีจุดตัดลดลง 1

ซึ่งถ้าเรานับจำนวนจุดตัดสำหรับทุกๆ $y$ จะช้ามาก  
ดังนั้นเราจะใช้ **Sweep Line**

### แนวคิด

- ที่จุดเริ่มของช่วง (`mn`) ให้เพิ่มค่า +1 
  หมายถึง มีช่วงหนึ่งเริ่มต้นที่นี่
- ที่จุดสิ้นสุดของช่วง (`mx`) ให้ลดค่า -1 
  หมายถึง มีช่วงหนึ่งจบลงที่นี่

เมื่อเราทำแบบนี้กับทุกช่วงแล้ว  
เราจะสามารถรู้ได้ว่า ณ แต่ละ $y$ จะมีการเปลี่ยนแปลงของจำนวนจุดตัดทั้งหมดกี่จุด  

จากนั้น เราแค่กวาด **(Sweep)** ตาม Map ที่เก็บว่ามีการเปลี่ยนแปลงของจุดตัดกี่จุด
แล้วบวกค่าขึ้นเรื่อย ๆ  
เช่น  
$$
sum += \text{ค่าที่เปลี่ยน ณ จุดนี้}
$$

ตัวแปร $sum$ จะบอกว่า “ตอนนี้มีช่วงกี่เส้นที่ยังถูกตัดอยู่” และเราก็เก็บค่า $sum$ ที่มากที่สุดที่ได้เกิดขึ้นมาระหว่างการกวาด

---

### ขั้นตอน
1. Input
2. สำหรับแต่ละคู่ของตัวเลข $(ก่อนหน้า, ตัวถัดไป)$
    - หา $y$ เริ่มต้นของส่วนของเส้นตรงปัจจุบัน โดยการเปรียบเทียบหาค่าที่**น้อย**กว่าระหว่าง $y$ ปัจจุบัน กับ $y$ ก่อนหน้านี้ $(prev)$ เก็บในตัวแปรชื่อ $mn$
    - หา $y$ สิ้นสุดของส่วนของเส้นตรงปัจจุบัน โดยการเปรียบเทียบหาค่าที่**มาก**กว่าระหว่าง $y$ ปัจจุบัน กับ $y$ ก่อนหน้านี้ $(prev)$ เก็บในตัวแปรชื่อ $mx$
    - เก็บใน map ว่า  
        - $a[mn]$++ (เริ่มช่วง)  
        - $a[mx]$-- (จบช่วง)  
3. วนดูค่าทั้งหมดใน map ตามลำดับจากน้อยไปมาก  
    - เราจะ Loop ตามค่าการเปลี่ยนแปลงสำหรับแต่ละ $y$ และในแต่ละรอบที่เราวน เราจะเพิ่มค่าการเปลี่ยนแปลงไปในตัวแปร $sum$ 
    - สร้างตัวแปร $ans$ เพื่อเก็บ $sum$ ที่มากที่สุดที่มีมา
4. Output

---

## Code: 

```cpp title="c2_kmutt_66_intersection.cpp"
#include <bits/stdc++.h>
#define int long long

using namespace std;

int main() {
    cin.tie(NULL)->sync_with_stdio(false);

    // Input
    int n;
    cin >> n;

    // Map ชื่อ mp เก็บข้อมูลสำหรับแต่ละจุด
    map <int, int> mp;

    // รับ Input ตัวแรกมาก่อน เพื่อป้องกันปัญหาเรื่อง Indexing
    int prev;
    cin >> prev;

    // รับ Input ตัวอื่นๆ พร้อมกับเก็บข้อมูลใน Map
    for (int i = 1; i < n; i++) {
        int y;
        cin >> y;
        int mn = min(y, prev);
        int mx = max(prev, y);
        prev = y;
        mp[mn]++;
        mp[mx]--;
    }
    
    // Loop หาค่ามากสุด
    int ans = 0;
    int sum = 0;
    for (auto [idx, cnt] : mp) {
        sum += cnt;
        ans = max(ans, sum);
    }

    // output
    cout << ans;

    return 0;
}



```
!!! note "Total Time Complexity"
    $O(N \log N)$
