---
title: TOI11_Place
---
# คำอธิบายวิธีทำพร้อม code สำหรับข้อ [toi11_place](https://programming.in.th/tasks/toi11_place)
---
### **Author**: Nagorn Phongphasura
---

## **Problem**
---

### **สรุปโจทย์**

พระราชาองค์หนึ่งต้องไปสักการะสถานที่ศักดิ์สิทธิ์ให้ครบทั้ง $N$ แห่ง โดยทุกๆเมืองถูกเชื่อมกันด้วยถนน $M$ เส้น แต่ละเส้นยาว $l_i$ เมตร $1 \leq i \leq M$ โดยมีเงื่อนไขว่า:
1. เพื่อความสะดวก เส้นทางที่พระราชาเดินทางต้องมีจำนวนเส้น**น้อยที่สุด** แต่ต้องสามารถเดินทางได้ **ครบทุกสถานที่**
2. ความยาวรวมของถนนทุกเส้นที่ถูกเลือก จะต้องมีค่า **มากที่สุด**
3. เพื่อการเฉลิมพระเกียรติ ทุกเส้นทางจะปักธง จำนวน $l_i - 1$ ธง
---

### **ตัวอย่าง**
พิจารณาภาพดังต่อไปนี้ 

![example1](../assets/images/place.png)

จะได้ว่า จำนวนธงที่ต้องใช้ เท่ากับ $(6-1) + (8-1) + (9-1) + (7-1) + (8-1) = 33$ ธง

---

### **สิ่งที่ต้องทำ**

หาจำนวนธงที่ต้องใช้ จากเงื่อนไขการเลือกเส้นทางดังกล่าว

---

!!! note "Constraints"
    $2 \leq N \leq 2 \times 10^5$ (จำนวนสถานที่ศักดิ์สิทธิ์)<br>
    $1 \leq M \leq 10^6$ (จำนวนถนน)<br>
    $1 \leq l_i \leq 10^5$ (ความยาวถนนแต่ละเส้น)<br>

!!! note "Prerequisites"
    - `Disjoint Set Union`
    - `Minimum Spanning Tree`

---

## **Solution**

สังเกตว่า สำหรับข้อนี้ สิ่งที่เราต้องทำคือ หาชุดของ**ถนน** ที่จะทำให้ทุกเมืองเชื่อมกัน และ**ความยาวมากที่สุด** ซึ่งสามารถทำได้โดยการใช้ **MST (Minimum Spanning Tree)** นั่นเอง

แต่ก่อนที่เราจะสามารถทำ MST ได้ เราจะต้องเรียนเกี่ยวกับ **DSU (Disjoint Set Union)** กันก่อน

---

### **DSU (Disjoint Set Union)**
---
#### **หน้าที่ของ DSU**
ลองนึกภาพตามกันดูนะครับ หากเรามีปัญหาแบบนี้:

- สมมติมีเกาะ $N$ เกาะ (ทุกเกาะแยกจากกันหมด) 
- แล้วเราค่อยๆ**เชื่อม**เกาะด้วยสะพาน 
- แล้วเราอยากทราบในช่วงขณะหนึ่งว่า: **"ถ้าหากว่าเราอยู่ที่เกาะ $X$ เราสามารถเดินไปยังเกาะ $Y$ ได้หรือไม่"**

นี่คือปัญหาที่ **DSU** ถูกออกแบบมาให้แก้ไข โดย DSU จะมีหลักๆ อยู่ 2 ฟังก์ชั่น ได้แก่:

1. `find(x)` จะหาว่า **เกาะแม่**ของ $X$ คือเกาะใด
2. `union(x, y)` จะทำหน้าที่**เชื่อม**เกาะ $X$ และเกาะ $Y$ เข้าด้วยกัน

ดังนั้น เมื่อเราอยากจะรู้ว่า สองเกาะใดๆสามารถเดินทางไปมาหากันได้หรือไม่ ก็แค่เช็กว่า `find(x) == find(y)` **เป็นจริง**หรือไม่

- $True$: แสดงว่า **เกาะแม่**ของ $X$ และ $Y$ คือเกาะเดียวกัน นั่นคือ เราสามารถเดินทางจาก $X$ ไปยัง $Y$ ได้
- $False$: แสดงว่า **เกาะแม่**ของ $X$ และ $Y$ เป็นคนละเกาะกัน นั่นคือ เรา**ไม่**สามารถเดินทางจาก $X$ ไปยัง $Y$ ได้

ซึ่ง DSU จะทำหน้าที่ในการ **ตั้งให้เกาะแม่** เป็นเกาะเดียวกัน เมื่อ 2 เกาะใดๆ ถูก `Union` เข้าด้วยกัน

---
#### **วิธีการทำงานของ DSU**
ก่อนอื่น เราจะมีอาเรย์ `parent` เพื่อเก็บว่า `parent[x] = เกาะแม่ของ X` โดยตอนต้น `parent[x] = x` สำหรับทุกๆ $X$

1. $find()$: 

    การเขียนฟังก์ชั่น $find()$ คือการ **ไต่ไปหาเกาะแม่** ดังนั้น ในการเขียนฟังก์ชั่นนี้ เราก็แค่ต้องเขียนดังนี้:
```cpp title="find()"
int find(int x){
    if (x == parent[x]) return x; // หากเราไต่มาถึงเกาะแม่แล้ว ก็ตอบไปเลย
    else return find(parent[x]); // แต่ถ้าเกาะนี้ยังไม่ใช่เกาะแม่ ก็ให้ไต่ต่อไป (ซึ่งก็คือการ find ขึ้นไปต่อ)
}
```
    แต่จากโค้ดนี้ หากลองสังเกตดู จะเห็นได้ว่า การไต่เนี่ย เนื่องจากเวลาเรา**เชื่อมเกาะ $X$ และ $Y$** เราก็แค่ตั้งให้ `parent[find(x)] = find(y)` นั่นคือ: 
    
    1. ตั้งให้ เกาะแม่ ของ เกาะแม่ ของ $X$ เป็นเกาะแม่ของ $Y$ 
    2. เมื่อไต่จาก $X$ จะไปพบเกาะแม่ของ $Y$ และเมื่อไต่จาก $Y$ ก็จะพบเกาะแม่ของ $Y$ เช่นกัน 
    3. ทำให้พบเกาะแม่เดียวกัน นั่นคือ เชื่อมกันเรียบร้อยแล้ว 
    
    ซึ่งการทำแบบนี้ อาจจะทำให้การ**ไต่ขึ้นไป**นั้น ต้องไต่เรื่อยๆถึง $N$ ครั้ง ซึ่งอาจทำให้ช้าได้ ดังนั้น เราจึงมีวิธีทำให้ $find()$ เร็วขึ้น โดยการเขียนดังนี้:
```cpp title="find()"
int find(int x){
    if (x == parent[x]) return x; // ทำเหมือนเดิม
    else {
        parent[x] = find(parent[x]); // แทนที่จะแค่ไต่ขึ้นไป ให้ตั้งให้ parent[x] = เกาะแม่ ก่อน ซึ่งจะทำให้การ find(x) ครั้งต่อไป สามารถหยุดได้เลย (เนื่องจาก เราได้ตั้งเกาะแม่ไว้ที่ X แล้ว)
        return parent[x];
    }
}
```

2. $union()$

    ฟังก์ชั่น $union()$ คือการ **เชื่อมเกาะ 2 เกาะ** เข้าด้วยกัน ซึ่งง่ายมากๆ ก็คือแค่ตั้งให้ **เกาะแม่ของ $X$** เป็น **เกาะแม่ของ $Y$** สามารถเขียนได้ดังนี้:
```cpp title="union()"
void union(int x, int y){
    int px = find(x); // หาเกาะแม่ของ X
    int py = find(y); // หาเกาะแม่ของ Y
    parent[px] = py; // ตั้งให้เกาะแม่ของ X เป็นเกาะแม่ของ Y
}
```
สามารถดูวิดีโอเพื่อให้เข้าใจ **DSU** มากขึ้นได้[ที่นี่](https://youtu.be/92UpvDXc8fs?si=knIFqG_4j5QQ3pJR)

---

### **วิธีทำ**

---

## **Code**

```cpp title="TOI13_Traveler.cpp"
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int inf = 1e18;

int32_t main(){
    cin.tie(NULL)->sync_with_stdio(false);

    // input
    int n, m, x, y, z;
    cin >> n >> m >> x >> y >> z;
    vector <pair <int, int>> adj[n];
    for(int i = 0; i < m; i++){
        int a, b, c;
        cin >> a >> b >> c;
        adj[a].emplace_back(c, b);
        adj[b].emplace_back(c, a);
    }

    priority_queue <pair <int, int>, vector <pair <int, int>>, greater <pair <int, int>>> q;

    // Dijkstra's Algorithm on X
    vector <int> dis_x(n, inf);
    dis_x[x] = 0;
    q.emplace(0, x);
    while (!q.empty()) {
        auto [w, u] = q.top();
        q.pop();
        for (auto [ww, v] : adj[u]) {
            if (w + ww >= dis_x[v]) continue;
            dis_x[v] = w + ww;
            q.emplace(w + ww, v);
        }
    }

    // Dijsktra's Algorithm on Y
    vector <int> dis_y(n, inf);
    dis_y[y] = 0;
    q.emplace(0, y);
    while (!q.empty()) {
        auto [w, u] = q.top();
        q.pop();
        for (auto [ww, v] : adj[u]) {
            if (w + ww >= dis_y[v]) continue;
            dis_y[v] = w + ww;
            q.emplace(w + ww, v);
        }
    }

    if (dis_x[y] <= z) { // หากระยะจากเมือง X ไปเมือง Y มีค่าน้อยกว่าหรือเท่ากับงบประมาณ ก็ตอบออกไปได้เลย
        cout << y << ' ' << dis_x[y] << ' ' << 0; // พิมพ์เมือง Y, ระยะทางจากเมือง X ไปเมือง Y, ระยะจากเมือง Y ไปเมือง Y (ซึ่งคือ 0 นั่นเอง)
        return 0; // จบการทำงานของโปรแกรม
    }

    int node = 0, len = inf; // ตั้งระยะที่สั้นที่สุดเป็นค่ามากๆ (ในที่นี้ กำหนด inf เป็น 10^18)
    for (int i = 0; i < n; i++) {
        if (dis_x[i] <= z && dis_y[i] < len) { // ตรวจสอบว่า ระยะจากเมือง X น้อยกว่า Z หรือไม่ และตรวจสอบอีกว่าระยะจากเมือง Y มีค่าน้อยกว่าระยะที่น้อยที่สุดที่พบมาแล้วหรือไม่  
            node = i;
            len = dis_y[i];
        }
    }

    cout << node << ' ' << dis_x[node] << ' ' << dis_y[node]; // พิมพ์เลขเมืองที่จะเดินทางไปให้มารับ, ระยะจากเมือง X, ระยะจากเมือง Y
}
```

!!! note "Total Time Complexity"
    $O((N + M)$ $log$ $N)$
