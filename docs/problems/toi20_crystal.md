---
title: toi21_duty_free
tags: [TOI, LIS, Coordinate Compression, Hard]
---
# [toi21\_crystal](https://otog.in.th/problem/1089)

---

## ‡∏™‡∏£‡∏∏‡∏õ‡πÇ‡∏à‡∏ó‡∏¢‡πå

‡∏°‡∏µ‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏≠‡∏¢‡∏π‡πà \$U\$ ‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏• ‡πÅ‡∏•‡∏∞‡∏°‡∏µ Crystal \$N\$ ‡∏≠‡∏±‡∏ô
‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏±‡∏ô‡∏°‡∏µ

* \$p\[i]\$: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
* \$w\[i]\$: ‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•
* \$t\[i]\$: ‡πÄ‡∏ß‡∏•‡∏≤

‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Å‡πá‡∏ö Crystal ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°

1. \$p\[i]\$ ‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å
2. \$t\[i]\$ ‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å

‡∏Ç‡∏ì‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏• \$j\$ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÑ‡∏î‡πâ 1 ‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡∏à‡∏≤‡∏Å 2 operations

1. ‡πÄ‡∏Å‡πá‡∏ö Crystal ‡πÉ‡∏ô‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏Ç‡πâ‡∏≤‡∏°‡∏ö‡∏≤‡∏á‡∏≠‡∏±‡∏ô‡πÑ‡∏î‡πâ)
2. ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏≠‡∏∑‡πà‡∏ô ‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏µ‡∏¢ Crystal \$K\$ ‡∏≠‡∏±‡∏ô (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÄ‡∏Å‡πá‡∏ö‡∏°‡∏≤‡πÅ‡∏•‡πâ‡∏ß ‚â• \$K\$)

**‡πÇ‡∏à‡∏ó‡∏¢‡πå:** ‡∏´‡∏≤‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡πá‡∏ö Crystal ‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏£

## !!! note "Prerequisites" - LIS (Longest Increasing Subsequence), Fenwick Tree, Sweep Line, Coordinate Compression

## Solution

## ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏≥

‡πÄ‡∏£‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏±‡∏á‡πÄ‡∏Å‡∏ï‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤ ‡∏ñ‡πâ‡∏≤ \$U = 1\$ ‡πÅ‡∏•‡∏∞ sort Crystal ‡∏î‡πâ‡∏ß‡∏¢ \$p\[i]\$ ‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å ‡∏à‡∏∞‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏´‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß LIS ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤ (‡∏ï‡∏≤‡∏°‡∏Ñ‡πà‡∏≤ \$t\$)

‡∏î‡∏±‡∏á‡∏ô‡∏±‡πâ‡∏ô‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏°‡∏µ array `v` ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£ sort Crystal ‡∏î‡πâ‡∏ß‡∏¢ \$p\_i\$ ‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥ sweep line ‡∏ï‡∏≤‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á `v` (‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡∏µ‡πâ‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î‡∏ñ‡∏∂‡∏á Crystal ‡∏ó‡∏µ‡πà `i` ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á Crystal ‡∏ó‡∏µ‡πà `i` ‡∏Ç‡∏≠‡∏á array `v`)

‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤‡πÄ‡∏£‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡πÄ‡∏Å‡πá‡∏ö Crystal ‡∏ó‡∏µ‡πà `i` ‡∏°‡∏µ 2 case ‡∏Ñ‡∏∑‡∏≠

* Crystal ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏Å‡πá‡∏ö Crystal `i` ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Crystal `i`
* Crystal ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏Å‡πá‡∏ö Crystal `i` ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Crystal `i`

‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤ case ‡∏ó‡∏µ‡πà 1 ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Crystal ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡πÉ‡∏´‡πâ \$c\_1\$ ‡πÅ‡∏ó‡∏ô‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ) ‡πÇ‡∏î‡∏¢‡∏ó‡∏µ‡πà Crystal ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏Å‡πá‡∏ö Crystal `i` ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö Crystal `i` ‡πÅ‡∏•‡∏∞ Crystal ‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ \$t < t\[i]\$.

‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤ case ‡∏ó‡∏µ‡πà 2 ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Crystal ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (‡πÉ‡∏´‡πâ \$c\_2\$ ‡πÅ‡∏ó‡∏ô‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ) ‡πÇ‡∏î‡∏¢‡∏ó‡∏µ‡πà Crystal ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡πÄ‡∏Å‡πá‡∏ö Crystal `i` ‡∏≠‡∏¢‡∏π‡πà‡∏Ñ‡∏ô‡∏•‡∏∞‡∏à‡∏±‡∏Å‡∏£‡∏ß‡∏≤‡∏•‡∏Å‡∏±‡∏ö Crystal `i` ‡πÅ‡∏•‡∏∞ Crystal ‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ \$t < t\[i]\$.

‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡∏≤‡∏≠‡∏¢‡∏≤‡∏Å‡πÄ‡∏Å‡πá‡∏ö Crystal ‡∏ó‡∏µ‡πà `i` ‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏™‡∏∏‡∏î‡∏Ñ‡∏∑‡∏≠ \$max(c\_1, c\_2 - k) + 1\$.

‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡∏ß‡πà‡∏≤‡∏ô‡∏µ‡πà‡∏Å‡πá‡∏Ñ‡∏∑‡∏≠‡πÇ‡∏à‡∏ó‡∏¢‡πå LIS ‡πÇ‡∏î‡∏¢‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ Fenwick tree ‡πÄ‡∏õ‡πá‡∏ô data structure ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ LIS (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏à‡∏≤‡∏Å‡∏ö‡∏ó‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ: [Longest Increasing Subsequence using BIT ‚Äî GeeksforGeeks](https://www.geeksforgeeks.org/longest-increasing-subsequence-using-bit))
**note:** ‡πÉ‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡πÉ‡∏ä‡πâ coordinate compression ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ

## code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;
const int inf = 1e18;
const int N = 100000 + 5;
const int U = 1000 + 5;

int u, k, n, ans;
map<int,int> com;
set<int> ins;
tuple<int,int,int> a[N]; // {t, w, p}

struct Fenwick {
    int fw[N];
    Fenwick() { fill(fw, fw+N, 0); }

    void update(int idx, int val) {
        while (idx < N) {
            fw[idx] = max(fw[idx], val);
            idx += idx & -idx;
        }
    }

    int query(int idx) {
        int res = 0;
        while (idx > 0) {
            res = max(res, fw[idx]);
            idx -= idx & -idx;
        }
        return res;
    }
} fenwick[U];

int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> u >> k >> n;
    for (int i = 1; i <= n; i++) {
        auto &tp = a[i];
        int p, w, t;
        cin >> p >> w >> t;
        // store as tuple {t, w, p} so sorting by tuple gives p-ascending then t-ascending if needed
        a[i] = make_tuple(t, w, p);
        ins.emplace(p);
    }

    vector<int> temp(ins.begin(), ins.end());
    for (size_t i = 0; i < temp.size(); ++i) {
        com[temp[i]] = (int)i + 1;
    }

    sort(a + 1, a + 1 + n); // sorts by t, then w, then p because tuple is (t,w,p)

    for (int i = 1; i <= n; i++) {
        int t, w, pp;
        tie(t, w, pp) = a[i];
        int p = com[pp];

        int x1 = fenwick[w].query(p - 1) + 1;
        int x2 = fenwick[U - 1].query(p - 1) + 1 - k;
        int x  = max(x1, x2);

        fenwick[U - 1].update(p, x);
        fenwick[w].update(p, x);

        ans = max(ans, x);
    }

    cout << ans << "\n";
    return 0;
}
```

---

## Total Time Complexity

\$O(n log n)\$ (‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£ sort ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Fenwick tree ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ element)

---

‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏™‡∏á‡∏™‡∏±‡∏¢ comment ‡πÑ‡∏ß‡πâ‡πÉ‡∏ï‡πâ post ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö üôá‚Äç‚ôÇÔ∏èüôá‚Äç‚ôÇÔ∏è
‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡πÇ‡∏à‡∏ó‡∏¢‡πå‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà [Fast X Fourier](https://fastxfourier.github.io/Home/)
