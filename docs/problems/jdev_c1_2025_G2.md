---
title: jdev_c1_2025_E
tags: [POSN1, String, Math, Hard]
---
# คำอธิบายวิธีทำพร้อม Code สำหรับข้อ [jdev_c1_2025_G2](https://codeforces.com/group/eScIVDG1u2/contest/638328/attachments/download/33732/E%20-%20Derivative.pdf)

---

## Problem 

### สรุปโจทย์
มีฟังก์ชัน $f(x)$ โดยที่เราต้องหา $f'(x)$(อนุพันธ์ของ $f(x)$ )

โดย $f(x)$ เป็นพหุนามที่ค่าสัมบูรณ์ของสัมประสิทธิ์ทุกตัวเป็นจำนวนเต็มและมีค่าไม่เกิน $10^9$ และดีกรีเป็นจำนวนเต็มบวกหรือ $0$ และมีค่าไม่เกิน $10^5$

โดยที่เราจะรับค่า $f(x)$ และต้องตอบค่า $f'(x)$ ในรูปแบบดังนี้:
1. ไม่มีช่องว่าง วงเล็บ จุดทศนิยม เครื่องหมายคูณหรือเครื่องหมายหาร
2. ไม่มีพจน์ใดที่ถูกเขียนมีสัมประสิทธิ์เป็นศูนย์ ยกเว้นเมื่อ $f(x) = 0$
3. แต่ละพจน์ถูกเรียงลำดับตามเลขชี้กำลังของ $x$ โดยจะเรียงจากมากไปน้อยและไม่ซ้ำกัน
4. พจน์แรกไม่นำหน้าด้วยเครื่องหมายบวก แต่สามารถนำหน้าด้วยเครื่องหมายลบได้
5. สัญลักษณ์บวก ลบ และยกกำลังแทนด้วย เครื่องหมาย + - และ ^ ตามลำดับ
6. เลขชี้กำลังและเลขสัมประสิทธิ์นำจะถูกเขียนก็ต่อเมื่อมีค่าสัมบูรณ์มากกว่าหนึ่ง

สำหรับคนที่ไม่รู้ว่าหาอนุพันธ์ยังไง สำหรับพหุนามแล้วมีกฎดังต่อไปนี้:
1. ถ้า $f(x) = x^n$ และ $n > 0$ แล้ว $f′(x) = nx^{n−1}$
2. ถ้า $f(x) = c$ โดยที่ $c$ เป็นค่าคงที่ แล้ว $f′(x) = 0$
3. ถ้า $f(x) = g(x) + h(x)$ แล้ว $f′(x) = g′(x) + h′(x)$
4. ถ้า $f(x) = c \times g(x)$ โดยที่ $c$ เป็นค่าคงที่ แล้ว $f′(x) = c \times g′(x)$

### สิ่งที่ต้องทำ
ให้หา $f'(x)$ ในรูปแบบที่ต้องการ

!!! note "Constraints"
	  $0 \leq $ดีกรีของ $f(x) \leq 10^5$<br>
	  $|$ สัมประสิทธิ์ทุกตัวของ $f(x)| \leq 10^9$

!!! note "Prerequisites"
	  - `Math`

---

## Solution

### ไอเดียหลัก
รับ Input พหุนาม $f(x)$ เป็น String แล้วหา Derivative ของมัน ตัวอย่างเช่น $−x^3+25x−3$ หมายถึงพจน์ 3 พจน์คือ

$−x^3$ (สัมประสิทธิ์ −1 ดีกรี 3)<br>
$+25x$ (สัมประสิทธิ์ +25 ดีกรี 1)<br>
$−3$ (ค่าคงที่)

1. ถ้า $f(x) = x^n$ และ $n > 0$ แล้ว $f′(x) = nx^{n−1}$
2. ถ้า $f(x) = c$ โดยที่ $c$ เป็นค่าคงที่ แล้ว $f′(x) = 0$
3. ถ้า $f(x) = g(x) + h(x)$ แล้ว $f′(x) = g′(x) + h′(x)$
4. ถ้า $f(x) = c \times g(x)$ โดยที่ $c$ เป็นค่าคงที่ แล้ว $f′(x) = c \times g′(x)$

นำผลลัพธ์ของแต่ละพจน์มารวมกันอีกครั้งเป็นสตริงผลลัพธ์ในรูปเดียวกันกับอินพุต

### ตัวอย่างการคำนวณ
$f(x) = −x^3 + 25x − 3$<br>
พจน์แรก: $−x^3$ $\rightarrow$ อนุพันธ์$=−3x^2$<br>
พจน์ที่สอง: $+25x$ $\rightarrow$ อนุพันธ์$=+25$<br>
พจน์ที่สาม: $−3$ $\rightarrow$ อนุพันธ์$=0$ (ไม่ต้องพิมพ์)

รวมผลลัพธ์ได้ $f′(x) = −3x^2 + 25$

### Solution
1. อ่านเครื่องหมาย + หรือ - เพื่อรู้ว่าพจน์เป็นบวกหรือลบ
2. อ่านตัวเลขสัมประสิทธิ์ ถ้าไม่มีหมายถึง $1$
3. ตรวจว่ามีตัวแปร $x$ หรือไม่
4. ถ้ามี $x$ ให้เช็กว่ามี ^ ตามมาหรือไม่ เพื่อเก็บค่าดีกรี
5. คำนวณค่าพจน์หลังอนุพันธ์ด้วยสูตร $a ∗ n$ และลดดีกรีลง $1$
6. สร้างสตริงผลลัพธ์ใหม่ตามรูปแบบที่กำหนด
7. พิมพ์คำตอบ

### **Edge Cases**
1. ถ้าอินพุตคือ $0$ ตอบ $0$
2. ถ้าอินพุตเป็นค่าคงที่ เช่น $7$ ตอบ $0$
3. ถ้าได้ผลลัพธ์เป็น $0$ ทุกพจน์ ตอบ $0$
4. ถ้าอนุพันธ์มีสัมประสิทธิ์ $1$ หรือ $−1$ ให้ละตัวเลขไว้เฉพาะเครื่องหมาย เช่น $x^2, −x$

---

## Code: 

```cpp title="jdev_c1_2025_E.cpp"
#include <bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    string s, ans = "";
    cin >> s;

    if (s.find('x') == string::npos) {
        cout << 0 << "\n";
        return 0;
    }

    int i = 0;
    while (i < s.length()) {
        int sign = 1;
        if (s[i] == '+' || s[i] == '-') {
            if (s[i] == '-') sign = -1;
            i++;
        }

        string temp = "";
        while (i < s.length() && isdigit(s[i])) {
            temp += s[i];
            i++;
        }

        int coef = (temp.empty() ? 1 : stoi(temp)) * sign;
        int power = 0;

        if (i < s.length() && s[i] == 'x') {
            power = 1;
            i++;
            if (i < s.length() && s[i] == '^') {
                i++;
                string exp = "";
                while (i < s.length() && isdigit(s[i])) {
                    exp += s[i];
                    i++;
                }
                power = stoi(exp);
            }
        }

        if (power == 0) continue;

        int newCoef = coef * power;
        int newPow = power - 1;

        if (newCoef > 0) ans += "+";
        ans += to_string(newCoef);

        if (newPow > 0) {
            ans += "x";
            if (newPow > 1) {
                ans += "^";
                ans += to_string(newPow);
            }
        }
    }

    if (!ans.empty() && ans[0] == '+') ans.erase(ans.begin());
    if (ans.empty()) ans = "0";

    cout << ans << "\n";
    return 0;
}
```
